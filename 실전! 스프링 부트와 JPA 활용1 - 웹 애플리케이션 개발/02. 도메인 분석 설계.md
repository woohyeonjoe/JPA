# 도메인 분석 설계

## 요구사항 분석

**강의자료 참고**

## 도메인 모델과 테이블 설계

![image](https://user-images.githubusercontent.com/106286686/216279363-8062bde9-52e8-4cff-912f-caaad500dd69.png)

엔티티

![image](https://user-images.githubusercontent.com/106286686/216279447-4b8bfc0f-f54c-43ee-8168-eb90341d83d3.png)

테이블

![image](https://user-images.githubusercontent.com/106286686/216279508-0800a62d-0f1c-48de-a652-50a4d5ee92ad.png)

**도메인, 엔티티, 테이블, 연관관계 분석은 강의자료 참고**

## 엔티티 클래스 개발

**엔티티 클래스 생성 및 매핑**

- Item-Category의 다대다 매핑은 실무에선 쓰지말자.
- Category는 자기자신을 매핑하는 구조

**프로젝트 코드 참고**

**getter는 모두 열어도 되지만 setter는 데이터 변경 지점이 어딘지 추적하기 힘들어진다.**

**그래서 엔티티를 변경할때는 setter를 여는게 아니라 변경 지점이 명확하도록 변경을 위한 비즈니스 메서드를 별도로 제공해야 한다.**

PK는 `Id`라고만 하지말고 `테이블명_Id`이런식으로 설정하자.

`Id`는 구분이 어렵고 관례상 `테이블명_Id` 를 많이 사용한다.

**값타입**

값타입은 불변객체로 만드는게 좋은 설계이다.

생성할때만 값을 세팅하고 setter를 제공하면 안된다.

**Address 엔티티 참고**

## 엔티티 설계시 주의점

- 엔티티에는 가급적 Setter를 사용하지 말자
- **모든 연관관계는 지연로딩으로 설정!**
    - 즉시로딩( EAGER )은 예측이 어렵고, 어떤 SQL이 실행될지 추적하기 어렵다. 특히 JPQL을 실행할 때 N+1문제가 자주 발생한다.
    - 실무에서 모든 연관관계는 지연로딩( LAZY )으로 설정해야 한다.
    연관된 엔티티를 함께 DB에서 조회해야 하면, fetch join 또는 엔티티 그래프 기능을 사용한다.
    - @XToOne(OneToOne, ManyToOne) 관계는 기본이 즉시로딩이므로 직접 지연로딩으로 설정해야 한다.
- 컬렉션은 필드에서 초기화 하자.
    - null 문제에서 안전하다.
    - 하이버네이트는 엔티티를 영속화 할 때, 컬랙션을 감싸서 하이버네이트가 제공하는 내장 컬렉션으로 변경한다. 만약 getOrders() 처럼 임의의 메서드에서 컬력션을 잘못 생성하면 하이버네이트 내부 메커니즘에 문제가 발생할 수 있다. 따라서 필드레벨에서 생성하는 것이 가장 안전하고, 코드도 간결하다.
- 스프링 부트 기본 테이블, 컬럼명 생성 전략
    - 카멜 케이스 → 언더스코어 (memberPoint → member_point)
    - .(점) → _(언더스코어)
    - 대문자 → 소문자
- CASCADE 속성
- 양방향 관계에선 연관관계 편의 메서드를 사용하자
    - 순수 객체 상태를 고려해서 항상 양쪽에 값을 설정하자 → 연관관계 편의 메서드로
